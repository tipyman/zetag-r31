{"entries":[{"timestamp":1769561489907,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":121,"diffs":[[1,""]]},{"start1":1,"length1":14651,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":232,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1769562017204,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4721,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1769563460443,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7411,"length1":0,"diffs":[[1,"    /**\n     * テストモード周期設定（秒）: 1..65535\n     */\n    //% blockId=Set_Test_Period block=\"Set Test Mode period %seconds (sec)\"\n    //% subcategory=\"Other\" weight=94 blockGap=8\n    //% seconds.min=1 seconds.max=65535 seconds.defl=1\n    export function Set_Test_Period(seconds: number): void {\n        if (seconds < 1) seconds = 1;\n        if (seconds > 65535) seconds = 65535;\n        const hi = (seconds >>> 8) & 0xFF;\n        const lo = seconds & 0xFF;\n        sendCommand(CMD_OP_MODE, [0x01, hi, lo]);\n    }\n"]]}]}]},{"timestamp":1769563495474,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7411,"length1":0,"diffs":[[1,"\n"]]},{"start1":8042,"length1":49,"diffs":[[1,"    export function Query_TX_Power(): number {\n"]]},{"start1":8286,"length1":3,"diffs":[[1,""]]},{"start1":8464,"length1":57,"diffs":[[1,"    //% chSpace.min=100 chSpace.max=255 chSpace.defl=100\n"]]},{"start1":8628,"length1":42,"diffs":[[1,"        if (chSpace > 255) chSpace = 255;\n"]]},{"start1":9521,"length1":54,"diffs":[[1,"    //% chStep.min=1 chStep.max=255 chStep.defl=2\n"]]},{"start1":9747,"length1":78,"diffs":[[1,"        if (chStep < 1) chStep = 1;\n        if (chStep > 255) chStep = 255;\n"]]}]}]},{"timestamp":1769564094958,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":9755,"length1":76,"diffs":[[1,"        if (chStep < 100) chStep = 100;\n        if (chStep > 255) chStep = 2;\n"]]},{"start1":11491,"length1":0,"diffs":[[1,"    /**\n     * シリアルボーレート設定 (0x45)\n     * 注意: 設定後はモジュール側ボーレートが即時切替\n     */\n    //% blockId=Set_Baudrate block=\"Set module baudrate %baud\"\n    //% subcategory=\"Init/Utility\" weight=60 blockGap=8\n    export function Set_Baudrate(baud: BaudSel): void {\n        sendCommand(CMD_BAUDRATE, [baud & 0xFF]);\n    }\n\n"]]},{"start1":12792,"length1":2,"diffs":[[1,"\n    // -----------------------------\n    // Init / Utility blocks\n    // -----------------------------\n\n    /**\n     * UART初期化（TX/RXピン・ボーレート）\n     * 注意: モジュール側の既定は 115200bps（仕様）\n     */\n    //% blockId=ZETag_init_serial block=\"Init UART TX %tx|RX %rx|Baud %baud\"\n    //% subcategory=\"Init/Utility\" weight=80 blockGap=8\n    export function Init_UART(tx: SerialPin, rx: SerialPin, baud: BaudRate): void {\n        serial.redirect(tx, rx, baud);\n        serial.setRxBufferSize(64);\n        serial.setTxBufferSize(64);\n    }\n\n    /**\n     * WAKEUPピンの設定（以後、通信時はHigh維持を推奨）\n     * 仕様: 通信の10ms以上前にHigh、通信中High、Lowでスリープ\n     */\n    //% blockId=ZETag_config_wakeup block=\"Configure WAKEUP pin %pin\"\n    //% subcategory=\"Init/Utility\" weight=79 blockGap=8\n    export function Configure_WAKEUP(pin: DigitalPin): void {\n        WAKEUP_ENABLED = true;\n        WAKEUP_PIN = pin;\n        pins.digitalWritePin(WAKEUP_PIN, 0);\n    }\n\n    /**\n     * WAKE（10ms以上High）\n     */\n    //% blockId=ZETag_wake block=\"Wake module (hold High ≥10ms)\"\n    //% subcategory=\"Init/Utility\" weight=78 blockGap=8\n    export function Wake(): void {\n        if (!WAKEUP_ENABLED) return;\n        pins.digitalWritePin(WAKEUP_PIN, 1);\n        pause(12);\n    }\n\n    /**\n     * SLEEP（Low）\n     */\n    //% blockId=ZETag_sleep block=\"Sleep module\"\n    //% subcategory=\"Init/Utility\" weight=77 blockGap=8\n    export function Sleep(): void {\n        if (!WAKEUP_ENABLED) return;\n        pins.digitalWritePin(WAKEUP_PIN, 0);\n    }\n}"]]}]}]},{"timestamp":1769564304448,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":350,"length1":2,"diffs":[[1,"\n"]]}]}]},{"timestamp":1769577441099,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"/**\n * makecode ZETag module Package Release 3.0 (Tailored to spec)\n * Original: Masakazu Urade (Tipyman) 2026/01/21\n */\n\n//% weight=100 color=#32CD32 icon=\"\\uf482\" block=\"ZETag R3.0\"\nnamespace ZETag_R30 {\n\n    // -----------------------------\n    // Constants & Types\n    // -----------------------------\n\n    const txBuffer = pins.createBuffer(1);\nｓ\n    // Frame types\n    const CMD_MAC = 0x01;\n    const CMD_VERSION = 0x02;\n    const CMD_SET_TX_MODE = 0x40; // 周波数/チャネル構成\n    const CMD_TX_POWER = 0x41; // 送信電力\n    const CMD_RADIO_PARAM = 0x42; // 無線パラメータ（変調・SR・CR）\n    const CMD_OP_MODE = 0x44; // 動作モード（透過/テスト）\n    const CMD_CH_SPACE_SET = 0xF0; // チャネル間隔（設定）\n    const CMD_CH_SPACE_QRY = 0xF1; // チャネル間隔（応答/クエリ）\n    const CMD_APP_DATA = 0x80; // アプリデータ送信\n    const CMD_ERROR = 0xFF; // エラーフィードバック\n\n    // Sub mode for CMD_SET_TX_MODE (0x40)\n    const SUB_SINGLE = 0x00; // 1ch（短縮）\n    const SUB_MULTI = 0x01; // 2ch以上（汎用）\n\n    // Rx status\n    export enum RxStatus {\n        OK = 0xFF, // 正常応答\n        TIMEOUT = 1,    // 受信タイムアウト\n        SIZE_ERR = 2,    // サイズ不一致\n        ZETAG_ERR = 3,    // ZETag側エラー(TYPE=0xFF)\n        CHECKSUM_ERR = 4,    // チェックサム不一致/Type突合不一致\n        FORMAT_ERR = 5     // フォーマット不正\n    }\n\n    // --- UI enums ---\n    export enum ChSpace {\n        //% block=\"100\"\n        KHz100 = 100,\n        //% block=\"200\"\n        KHz200 = 200\n    }\n    export enum ChNum {\n        //% block=\"1\"\n        _1 = 1,\n        //% block=\"2\"\n        _2 = 2,\n        //% block=\"3\"\n        _3 = 3,\n        //% block=\"4\"\n        _4 = 4,\n        //% block=\"5\"\n        _5 = 5,\n        //% block=\"6\"\n        _6 = 6,\n    }\n    export enum TxPower {\n        //% block=\"2\"\n        dBm2 = 2,\n        //% block=\"4\"\n        dBm4 = 4,\n        //% block=\"6\"\n        dBm6 = 6,\n        //% block=\"8\"\n        dBm8 = 8,\n        //% block=\"10\"\n        dBm10 = 10,\n    }\n    export enum Mode {\n        //% block=\"4FSK(600sps,1/2)\"\n        FSK4 = 0,\n        //% block=\"(予約)8FSK\"\n        FSK8 = 1 // 仕様未定義のため送信値は 0x01 に固定\n    }\n    export enum OP_Mode {\n        //% block=\"Normal\"\n        Normal = 0,\n        //% block=\"Test\"\n        Test = 1\n    }\n\n    // Init / WAKEUP settings\n    let WAKEUP_ENABLED = false\n    let WAKEUP_PIN: DigitalPin = DigitalPin.P8\n\n    // -----------------------------\n    // Low-level helpers\n    // -----------------------------\n\n    /** TX one byte (0..255) */\n    function UART_BIN_TX(txData: number): void {\n        txBuffer.setUint8(0, txData & 0xFF);\n        serial.writeBuffer(txBuffer);\n    }\n\n    /** RX one byte (blocking); returns 0..255 */\n    function UART_BIN_RX(): number {\n        const rxBuffer = serial.readBuffer(1); // blocking\n        if (rxBuffer.length > 0) return rxBuffer[0] & 0xFF;\n        return 0;\n    }\n\n    /** Sum of bytes (8-bit) */\n    function checksum8(bytes: number[]): number {\n        let sum = 0;\n        for (let i = 0; i < bytes.length; i++) sum = (sum + (bytes[i] & 0xFF)) & 0xFF;\n        return sum & 0xFF;\n    }\n\n    /**\n     * Receive: FF 00 LEN [Type..(LEN-1 bytes)] CRC\n     * 戻り: [status(=0xFF), 0x00, LEN, Type, ..., CRC] or [RxStatus.*]\n     */\n    function receive_query(): number[] {\n        let timeoutCounter = 0;\n\n        // sync FF\n        while (true) {\n            const d = UART_BIN_RX();\n            if (d === 0xFF) break;\n            if (++timeoutCounter > 15) return [RxStatus.TIMEOUT];\n        }\n\n        // expect 00\n        const b1 = UART_BIN_RX();\n        if (b1 !== 0x00) return [RxStatus.FORMAT_ERR];\n\n        // read LEN\n        const len = UART_BIN_RX() & 0xFF;\n        if (len < 2) return [RxStatus.FORMAT_ERR]; // 最小: Type(1)+CRC(1)\n\n        // read (LEN-1) bytes (Type + Data...)\n        const typeAndData: number[] = [];\n        for (let i = 0; i < len - 1; i++) typeAndData.push(UART_BIN_RX() & 0xFF);\n\n        // read CRC\n        const crc = UART_BIN_RX() & 0xFF;\n\n        // verify checksum\n        const calc = checksum8([0xFF, 0x00, len].concat(typeAndData));\n        if (calc !== crc) return [RxStatus.CHECKSUM_ERR];\n\n        // OK\n        return [RxStatus.OK, 0x00, len].concat(typeAndData).concat([crc]);\n    }\n\n    /**\n     * sendCommand: [FF,00,LEN, Type, ...payload..., CRC]\n     * LEN = 1(Type) + payload.length + 1(CRC)\n     */\n\n    function sendCommand(type: number, payload: number[] = []): number[] {\n        // WAKEUP 高維持（必要時）\n        pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        const len = 1 + payload.length + 1;\n        const header = [0xFF, 0x00, len, type];\n        const crc = checksum8(header.concat(payload));\n\n        const frame = header.concat(payload);\n        frame.push(crc); // ← ここがポイント\n\n        for (let i = 0; i < frame.length; i++) UART_BIN_TX(frame[i]);\n\n        return receive_query();\n    }\n\n    // -----------------------------\n    // Public APIs\n    // -----------------------------\n\n    /**\n     * 完成済みフレームをそのまま送信→受信\n     * queryData[0] = RxStatus\n     */\n    //% blockId=Send_ZETag_command block=\"Send ZETag command %txArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Send_ZETag_command(txArray: number[]): number[] {\n        if (WAKEUP_ENABLED) pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        for (let i = 0; i < txArray.length; i++) UART_BIN_TX(txArray[i] & 0xFF);\n\n        const rsp = receive_query();\n        if (rsp[0] !== RxStatus.OK) return rsp;\n\n        const reqType = txArray[3] & 0xFF;\n        const rspType = rsp[3] & 0xFF;\n\n        // 例外: F0(設定)→F1(応答)を許容\n        const okType =\n            (rspType === reqType) ||\n            (reqType === CMD_CH_SPACE_SET && rspType === CMD_CH_SPACE_QRY);\n\n        // エラーフレーム TYPE=0xFF\n        if (rspType === CMD_ERROR) {\n            rsp[0] = RxStatus.ZETAG_ERR;\n            return rsp;\n        }\n\n        if (!okType) rsp[0] = RxStatus.CHECKSUM_ERR;\n        return rsp;\n    }\n\n    /**\n     * アプリケーションデータ送信 (0x80), N<=30\n     */\n    //% blockId=Transmit_ZETag_data block=\"Transmit ZETag data %dataArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Transmit_ZETag_data(txArray: number[]): void {\n        if (!txArray || txArray.length < 1) return;\n        let n = txArray.length;\n        if (n > 30) n = 30; // 仕様上限\n\n        const payload = txArray.slice(0, n);\n        const rsp = sendCommand(CMD_APP_DATA, payload);\n        // 応答は 0x80 0x81（成功） or 0xFF（エラー）\n    }\n\n    /**\n     * バージョン取得 (0x02)\n     * 戻り: 上位4bit=メイン、下位4bit=サブ\n     */\n    //% blockId=Get_Protocol_Version block=\"Get Protocol Version\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    export function Get_Protocol_Version(): number {\n        const rsp = sendCommand(CMD_VERSION, []); // payloadなし\n        if (rsp[0] !== RxStatus.OK) return 0;\n\n        const main = (rsp.length > 5) ? (rsp[4] & 0x0F) : 0;\n        const sub = (rsp.length > 6) ? (rsp[5] & 0x0F) : 0;\n        return ((main << 4) | sub) & 0xFF;\n    }\n\n    /**\n     * 動作モード設定 (0x44)\n     * Normal: FF 00 03 44 00 46\n     * Test  : FF 00 05 44 01 [periodHi] [periodLo] CRC\n     */\n    //% blockId=Set_Operating_Mode block=\"Set Operating Mode %mode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% mode.min=0 mode.max=1 mode.defl=0\n    export function Set_Operating_Mode(mode: OP_Mode): void {\n        if (mode === OP_Mode.Test) {\n            // 既定周期1秒：別ブロック setTestMode() で任意指定可\n            sendCommand(CMD_OP_MODE, [0x01, 0x00, 0x01]);\n        } else {\n            // 透過（パススルー）\n            sendCommand(CMD_OP_MODE, [0x00]);\n        }\n    }\n\n    /**\n     * 送信電力設定 (0x41)\n     * 0.5dB/step, 0x10=8dBm, 0x14=10dBm\n     */\n    //% blockId=Set_TX_Power block=\"Set TX Power %txPower (dB)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txPower.min=1 txPower.max=10 txPower.defl=10\n    export function Set_TX_Power(txPower: number): void {\n        if (txPower < 1) txPower = 1;\n        if (txPower > 10) txPower = 10;\n        const reg = (txPower * 2) & 0xFF;\n        sendCommand(CMD_TX_POWER, [reg]);\n    }\n\n    /**\n     * 送信電力クエリ (0x04) → 応答 0x04 [power]\n     */\n    //% blockId=Query_TX_Power block=\"Query TX Power\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n/*    export function Query_TX_Power(): number {\n        const rsp = sendCommand(0x04, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        // rsp: [OK,0x00,LEN,0x04,power,CRC]\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n*/\n\n    /**\n     * チャネル間隔設定 (0xF0), 応答は 0xF1\n     */\n    //% blockId=Set_channel_spacing block=\"Set channel spacing %chSpace (kHz)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% chSpace.min=100 chSpace.max=200 chSpace.defl=100\n    export function Set_channel_spacing(chSpace: number): void {\n        if (chSpace < 100) chSpace = 100;\n        if (chSpace > 200) chSpace = 200;\n        sendCommand(CMD_CH_SPACE_SET, [chSpace & 0xFF]);\n    }\n\n    /**\n     * チャネル間隔クエリ (0xF1) → 応答 0xF1 [space]\n     */\n    //% blockId=Query_channel_spacing block=\"Query channel spacing\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_channel_spacing(): number {\n        const rsp = sendCommand(CMD_CH_SPACE_QRY, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n\n    /**\n     * 周波数設定 (0x40)\n     * 1ch:   0x40 0x00 [Freq4B]\n     * 2..6ch:0x40 0x01 [Freq4B] [chNum] [channelNumbers...]\n     */\n    //% blockId=Set_Frequency block=\"Set Frequency %frequency (Hz) %chNum (ch) %chStep\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chNum.min=1 chNum.max=6 chNum.defl=2\n    //% chStep.min=100 chStep.max=200 chStep.defl=100\n    export function Set_Frequency(frequency: number, chNum: number, chStep: number): void {\n        // clip\n        if (chNum < 1) chNum = 1;\n        if (chNum > 6) chNum = 6;\n        if (chStep < 100) chStep = 2;\n        if (chStep > 200) chStep = 1;\n\n        // region clip（運用帯: 470–510MHz / 920–928MHz）\n        if (frequency < 470000000) frequency = 470000000;\n        else if (frequency > 928000000) frequency = 928000000;\n\n        const f3 = (frequency >>> 24) & 0xFF;\n        const f2 = (frequency >>> 16) & 0xFF;\n        const f1 = (frequency >>> 8) & 0xFF;\n        const f0 = (frequency) & 0xFF;\n\n        if (chNum === 1) {\n            // single channel (short)\n            const payload = [SUB_SINGLE, f3, f2, f1, f0];\n            sendCommand(CMD_SET_TX_MODE, payload);\n        } else {\n            // multi channel\n            const payload: number[] = [SUB_MULTI, f3, f2, f1, f0, chNum];\n            for (let n = 0; n < chNum; n++) payload.push((n * chStep) & 0xFF);\n            sendCommand(CMD_SET_TX_MODE, payload);\n        }\n    }\n\n    /**\n     * 無線パラメータ設定 (0x42)\n     * 仕様上 0x01=4FSK+600sps+1/2 のみ明記。FSK8 は予約。\n     */\n    //% blockId=Set_TX_Mode block=\"Set TX Mode %txMode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txMode.defl=Mode.FSK4\n    export function Set_TX_Mode(txMode: Mode): void {\n        // 仕様値 0x01 固定（FSK8 選択時も暫定）\n        sendCommand(CMD_RADIO_PARAM, [0x01]);\n    }\n\n    /**\n     * MACアドレスのクエリ (0x01) → 応答 0x01 [MAC3][MAC2][MAC1][MAC0]\n     */\n    //% blockId=Query_MAC block=\"Query MAC address\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_MAC(): number[] {\n        const rsp = sendCommand(CMD_MAC, []);\n        if (rsp[0] !== RxStatus.OK) return [];\n        // rsp: [OK,0x00,LEN,0x01, MAC3,MAC2,MAC1,MAC0, CRC]\n        if (rsp.length < 8) return [];\n        return [rsp[4] & 0xFF, rsp[5] & 0xFF, rsp[6] & 0xFF, rsp[7] & 0xFF];\n    }\n\n    // --- まとめ設定ブロック ---\n    /**\n     * ZETag の無線設定一括適用\n     */\n    //% blockId=zetag_setting\n    //% block=\"ZETag Setting|Frequency(Hz) %frequency|Band width(kHz) %chSpace|Number of Channel(ch) %chNum|Tx Power(dB) %txPower|Mode %mode\"\n    //% group=\"ZETag Setting\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chSpace.defl=ChSpace.KHz200\n    //% chNum.defl=ChNum._2\n    //% txPower.defl=TxPower.dBm8\n    //% mode.defl=Mode.FSK4\n    export function applySetting(\n        frequency: number,\n        chSpace: ChSpace,\n        chNum: ChNum,\n        txPower: TxPower,\n        mode: Mode\n    ): void {\n        // 0) 無線パラメータ（変調等）\n        Set_TX_Mode(mode);\n\n        // 1) チャネル間隔（例: 作法として 100kHz に固定）\n        Set_channel_spacing(ChSpace.KHz100);\n\n        // 2) 送信電力\n        Set_TX_Power(txPower);\n\n        // 3) 周波数＋チャネル\n        const chStep = (chSpace === ChSpace.KHz200) ? 2 : 1;\n        Set_Frequency(frequency, chNum, chStep);\n    }\n}\n"]]}]}]},{"timestamp":1769577445595,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":237,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":10945,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":232,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\n"}]}],"snapshots":[{"timestamp":1769561489906,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"ZETag-R31\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1769563460443,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/**\n * makecode ZETag module Package Release 3.0 (Tailored to spec)\n * Original: Masakazu Urade (Tipyman) 2026/01/21\n */\n\n//% weight=100 color=#32CD32 icon=\"\\uf482\" block=\"ZETag R3.0\"\nnamespace ZETag_R30 {\n\n    // -----------------------------\n    // Constants & Types\n    // -----------------------------\n\n    const txBuffer = pins.createBuffer(1);\n\n    // Frame types\n    const CMD_MAC = 0x01;\n    const CMD_VERSION = 0x02;\n    const CMD_SET_TX_MODE = 0x40; // 周波数/チャネル構成\n    const CMD_TX_POWER = 0x41; // 送信電力\n    const CMD_RADIO_PARAM = 0x42; // 無線パラメータ（変調・SR・CR）\n    const CMD_OP_MODE = 0x44; // 動作モード（透過/テスト）\n    const CMD_CH_SPACE_SET = 0xF0; // チャネル間隔（設定）\n    const CMD_CH_SPACE_QRY = 0xF1; // チャネル間隔（応答/クエリ）\n    const CMD_APP_DATA = 0x80; // アプリデータ送信\n    const CMD_ERROR = 0xFF; // エラーフィードバック\n\n    // Sub mode for CMD_SET_TX_MODE (0x40)\n    const SUB_SINGLE = 0x00; // 1ch（短縮）\n    const SUB_MULTI = 0x01; // 2ch以上（汎用）\n\n    // Rx status\n    export enum RxStatus {\n        OK = 0xFF, // 正常応答\n        TIMEOUT = 1,    // 受信タイムアウト\n        SIZE_ERR = 2,    // サイズ不一致\n        ZETAG_ERR = 3,    // ZETag側エラー(TYPE=0xFF)\n        CHECKSUM_ERR = 4,    // チェックサム不一致/Type突合不一致\n        FORMAT_ERR = 5     // フォーマット不正\n    }\n\n    // --- UI enums ---\n    export enum ChSpace {\n        //% block=\"100\"\n        KHz100 = 100,\n        //% block=\"200\"\n        KHz200 = 200\n    }\n    export enum ChNum {\n        //% block=\"1\"\n        _1 = 1,\n        //% block=\"2\"\n        _2 = 2,\n        //% block=\"3\"\n        _3 = 3,\n        //% block=\"4\"\n        _4 = 4,\n        //% block=\"5\"\n        _5 = 5,\n        //% block=\"6\"\n        _6 = 6,\n    }\n    export enum TxPower {\n        //% block=\"2\"\n        dBm2 = 2,\n        //% block=\"4\"\n        dBm4 = 4,\n        //% block=\"6\"\n        dBm6 = 6,\n        //% block=\"8\"\n        dBm8 = 8,\n        //% block=\"10\"\n        dBm10 = 10,\n    }\n    export enum Mode {\n        //% block=\"4FSK(600sps,1/2)\"\n        FSK4 = 0,\n        //% block=\"(予約)8FSK\"\n        FSK8 = 1 // 仕様未定義のため送信値は 0x01 に固定\n    }\n    export enum OP_Mode {\n        //% block=\"Normal\"\n        Normal = 0,\n        //% block=\"Test\"\n        Test = 1\n    }\n\n    // Init / WAKEUP settings\n    let WAKEUP_ENABLED = false\n    let WAKEUP_PIN: DigitalPin = DigitalPin.P8\n\n    // -----------------------------\n    // Low-level helpers\n    // -----------------------------\n\n    /** TX one byte (0..255) */\n    function UART_BIN_TX(txData: number): void {\n        txBuffer.setUint8(0, txData & 0xFF);\n        serial.writeBuffer(txBuffer);\n    }\n\n    /** RX one byte (blocking); returns 0..255 */\n    function UART_BIN_RX(): number {\n        const rxBuffer = serial.readBuffer(1); // blocking\n        if (rxBuffer.length > 0) return rxBuffer[0] & 0xFF;\n        return 0;\n    }\n\n    /** Sum of bytes (8-bit) */\n    function checksum8(bytes: number[]): number {\n        let sum = 0;\n        for (let i = 0; i < bytes.length; i++) sum = (sum + (bytes[i] & 0xFF)) & 0xFF;\n        return sum & 0xFF;\n    }\n\n    /**\n     * Receive: FF 00 LEN [Type..(LEN-1 bytes)] CRC\n     * 戻り: [status(=0xFF), 0x00, LEN, Type, ..., CRC] or [RxStatus.*]\n     */\n    function receive_query(): number[] {\n        let timeoutCounter = 0;\n\n        // sync FF\n        while (true) {\n            const d = UART_BIN_RX();\n            if (d === 0xFF) break;\n            if (++timeoutCounter > 15) return [RxStatus.TIMEOUT];\n        }\n\n        // expect 00\n        const b1 = UART_BIN_RX();\n        if (b1 !== 0x00) return [RxStatus.FORMAT_ERR];\n\n        // read LEN\n        const len = UART_BIN_RX() & 0xFF;\n        if (len < 2) return [RxStatus.FORMAT_ERR]; // 最小: Type(1)+CRC(1)\n\n        // read (LEN-1) bytes (Type + Data...)\n        const typeAndData: number[] = [];\n        for (let i = 0; i < len - 1; i++) typeAndData.push(UART_BIN_RX() & 0xFF);\n\n        // read CRC\n        const crc = UART_BIN_RX() & 0xFF;\n\n        // verify checksum\n        const calc = checksum8([0xFF, 0x00, len].concat(typeAndData));\n        if (calc !== crc) return [RxStatus.CHECKSUM_ERR];\n\n        // OK\n        return [RxStatus.OK, 0x00, len].concat(typeAndData).concat([crc]);\n    }\n\n    /**\n     * sendCommand: [FF,00,LEN, Type, ...payload..., CRC]\n     * LEN = 1(Type) + payload.length + 1(CRC)\n     */\n\n    function sendCommand(type: number, payload: number[] = []): number[] {\n        // WAKEUP 高維持（必要時）\n        pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        const len = 1 + payload.length + 1;\n        const header = [0xFF, 0x00, len, type];\n        const crc = checksum8(header.concat(payload));\n\n        const frame = header.concat(payload);\n        frame.push(crc); // ← ここがポイント\n\n        for (let i = 0; i < frame.length; i++) UART_BIN_TX(frame[i]);\n\n        return receive_query();\n    }\n\n\n    // -----------------------------\n    // Public APIs\n    // -----------------------------\n\n    /**\n     * 完成済みフレームをそのまま送信→受信\n     * queryData[0] = RxStatus\n     */\n    //% blockId=Send_ZETag_command block=\"Send ZETag command %txArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Send_ZETag_command(txArray: number[]): number[] {\n        if (WAKEUP_ENABLED) pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        for (let i = 0; i < txArray.length; i++) UART_BIN_TX(txArray[i] & 0xFF);\n\n        const rsp = receive_query();\n        if (rsp[0] !== RxStatus.OK) return rsp;\n\n        const reqType = txArray[3] & 0xFF;\n        const rspType = rsp[3] & 0xFF;\n\n        // 例外: F0(設定)→F1(応答)を許容\n        const okType =\n            (rspType === reqType) ||\n            (reqType === CMD_CH_SPACE_SET && rspType === CMD_CH_SPACE_QRY);\n\n        // エラーフレーム TYPE=0xFF\n        if (rspType === CMD_ERROR) {\n            rsp[0] = RxStatus.ZETAG_ERR;\n            return rsp;\n        }\n\n        if (!okType) rsp[0] = RxStatus.CHECKSUM_ERR;\n        return rsp;\n    }\n\n    /**\n     * アプリケーションデータ送信 (0x80), N<=30\n     */\n    //% blockId=Transmit_ZETag_data block=\"Transmit ZETag data %dataArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Transmit_ZETag_data(txArray: number[]): void {\n        if (!txArray || txArray.length < 1) return;\n        let n = txArray.length;\n        if (n > 30) n = 30; // 仕様上限\n\n        const payload = txArray.slice(0, n);\n        const rsp = sendCommand(CMD_APP_DATA, payload);\n        // 応答は 0x80 0x81（成功） or 0xFF（エラー）\n    }\n\n    /**\n     * バージョン取得 (0x02)\n     * 戻り: 上位4bit=メイン、下位4bit=サブ\n     */\n    //% blockId=Get_Protocol_Version block=\"Get Protocol Version\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    export function Get_Protocol_Version(): number {\n        const rsp = sendCommand(CMD_VERSION, []); // payloadなし\n        if (rsp[0] !== RxStatus.OK) return 0;\n\n        const main = (rsp.length > 5) ? (rsp[4] & 0x0F) : 0;\n        const sub = (rsp.length > 6) ? (rsp[5] & 0x0F) : 0;\n        return ((main << 4) | sub) & 0xFF;\n    }\n\n    /**\n     * 動作モード設定 (0x44)\n     * Normal: FF 00 03 44 00 46\n     * Test  : FF 00 05 44 01 [periodHi] [periodLo] CRC\n     */\n    //% blockId=Set_Operating_Mode block=\"Set Operating Mode %mode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% mode.min=0 mode.max=1 mode.defl=0\n    export function Set_Operating_Mode(mode: OP_Mode): void {\n        if (mode === OP_Mode.Test) {\n            // 既定周期1秒：別ブロック setTestMode() で任意指定可\n            sendCommand(CMD_OP_MODE, [0x01, 0x00, 0x01]);\n        } else {\n            // 透過（パススルー）\n            sendCommand(CMD_OP_MODE, [0x00]);\n        }\n    }\n\n    /**\n     * テストモード周期設定（秒）: 1..65535\n     */\n    //% blockId=Set_Test_Period block=\"Set Test Mode period %seconds (sec)\"\n    //% subcategory=\"Other\" weight=94 blockGap=8\n    //% seconds.min=1 seconds.max=65535 seconds.defl=1\n    export function Set_Test_Period(seconds: number): void {\n        if (seconds < 1) seconds = 1;\n        if (seconds > 65535) seconds = 65535;\n        const hi = (seconds >>> 8) & 0xFF;\n        const lo = seconds & 0xFF;\n        sendCommand(CMD_OP_MODE, [0x01, hi, lo]);\n    }\n\n    /**\n     * 送信電力設定 (0x41)\n     * 0.5dB/step, 0x10=8dBm, 0x14=10dBm\n     */\n    //% blockId=Set_TX_Power block=\"Set TX Power %txPower (dB)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txPower.min=1 txPower.max=10 txPower.defl=10\n    export function Set_TX_Power(txPower: number): void {\n        if (txPower < 1) txPower = 1;\n        if (txPower > 10) txPower = 10;\n        const reg = (txPower * 2) & 0xFF;\n        sendCommand(CMD_TX_POWER, [reg]);\n    }\n\n    /**\n     * 送信電力クエリ (0x04) → 応答 0x04 [power]\n     */\n    //% blockId=Query_TX_Power block=\"Query TX Power\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_TX_Power(): number {\n        const rsp = sendCommand(0x04, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        // rsp: [OK,0x00,LEN,0x04,power,CRC]\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n\n    /**\n     * チャネル間隔設定 (0xF0), 応答は 0xF1\n     */\n    //% blockId=Set_channel_spacing block=\"Set channel spacing %chSpace (kHz)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% chSpace.min=100 chSpace.max=255 chSpace.defl=100\n    export function Set_channel_spacing(chSpace: number): void {\n        if (chSpace < 100) chSpace = 100;\n        if (chSpace > 255) chSpace = 255;\n        sendCommand(CMD_CH_SPACE_SET, [chSpace & 0xFF]);\n    }\n\n    /**\n     * チャネル間隔クエリ (0xF1) → 応答 0xF1 [space]\n     */\n    //% blockId=Query_channel_spacing block=\"Query channel spacing\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_channel_spacing(): number {\n        const rsp = sendCommand(CMD_CH_SPACE_QRY, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n\n    /**\n     * 周波数設定 (0x40)\n     * 1ch:   0x40 0x00 [Freq4B]\n     * 2..6ch:0x40 0x01 [Freq4B] [chNum] [channelNumbers...]\n     */\n    //% blockId=Set_Frequency block=\"Set Frequency %frequency (Hz) %chNum (ch) %chStep\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chNum.min=1 chNum.max=6 chNum.defl=2\n    //% chStep.min=1 chStep.max=255 chStep.defl=2\n    export function Set_Frequency(frequency: number, chNum: number, chStep: number): void {\n        // clip\n        if (chNum < 1) chNum = 1;\n        if (chNum > 6) chNum = 6;\n        if (chStep < 1) chStep = 1;\n        if (chStep > 255) chStep = 255;\n\n        // region clip（運用帯: 470–510MHz / 920–928MHz）\n        if (frequency < 470000000) frequency = 470000000;\n        else if (frequency > 928000000) frequency = 928000000;\n\n        const f3 = (frequency >>> 24) & 0xFF;\n        const f2 = (frequency >>> 16) & 0xFF;\n        const f1 = (frequency >>> 8) & 0xFF;\n        const f0 = (frequency) & 0xFF;\n\n        if (chNum === 1) {\n            // single channel (short)\n            const payload = [SUB_SINGLE, f3, f2, f1, f0];\n            sendCommand(CMD_SET_TX_MODE, payload);\n        } else {\n            // multi channel\n            const payload: number[] = [SUB_MULTI, f3, f2, f1, f0, chNum];\n            for (let n = 0; n < chNum; n++) payload.push((n * chStep) & 0xFF);\n            sendCommand(CMD_SET_TX_MODE, payload);\n        }\n    }\n\n    /**\n     * 無線パラメータ設定 (0x42)\n     * 仕様上 0x01=4FSK+600sps+1/2 のみ明記。FSK8 は予約。\n     */\n    //% blockId=Set_TX_Mode block=\"Set TX Mode %txMode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txMode.defl=Mode.FSK4\n    export function Set_TX_Mode(txMode: Mode): void {\n        // 仕様値 0x01 固定（FSK8 選択時も暫定）\n        sendCommand(CMD_RADIO_PARAM, [0x01]);\n    }\n\n    /**\n     * MACアドレスのクエリ (0x01) → 応答 0x01 [MAC3][MAC2][MAC1][MAC0]\n     */\n    //% blockId=Query_MAC block=\"Query MAC address\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_MAC(): number[] {\n        const rsp = sendCommand(CMD_MAC, []);\n        if (rsp[0] !== RxStatus.OK) return [];\n        // rsp: [OK,0x00,LEN,0x01, MAC3,MAC2,MAC1,MAC0, CRC]\n        if (rsp.length < 8) return [];\n        return [rsp[4] & 0xFF, rsp[5] & 0xFF, rsp[6] & 0xFF, rsp[7] & 0xFF];\n    }\n\n    /**\n     * シリアルボーレート設定 (0x45)\n     * 注意: 設定後はモジュール側ボーレートが即時切替\n     */\n    //% blockId=Set_Baudrate block=\"Set module baudrate %baud\"\n    //% subcategory=\"Init/Utility\" weight=60 blockGap=8\n    export function Set_Baudrate(baud: BaudSel): void {\n        sendCommand(CMD_BAUDRATE, [baud & 0xFF]);\n    }\n\n    // --- まとめ設定ブロック ---\n    /**\n     * ZETag の無線設定一括適用\n     */\n    //% blockId=zetag_setting\n    //% block=\"ZETag Setting|Frequency(Hz) %frequency|Band width(kHz) %chSpace|Number of Channel(ch) %chNum|Tx Power(dB) %txPower|Mode %mode\"\n    //% group=\"ZETag Setting\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chSpace.defl=ChSpace.KHz200\n    //% chNum.defl=ChNum._2\n    //% txPower.defl=TxPower.dBm8\n    //% mode.defl=Mode.FSK4\n    export function applySetting(\n        frequency: number,\n        chSpace: ChSpace,\n        chNum: ChNum,\n        txPower: TxPower,\n        mode: Mode\n    ): void {\n        // 0) 無線パラメータ（変調等）\n        Set_TX_Mode(mode);\n\n        // 1) チャネル間隔（例: 作法として 100kHz に固定）\n        Set_channel_spacing(ChSpace.KHz100);\n\n        // 2) 送信電力\n        Set_TX_Power(txPower);\n\n        // 3) 周波数＋チャネル\n        const chStep = (chSpace === ChSpace.KHz200) ? 2 : 1;\n        Set_Frequency(frequency, chNum, chStep);\n    }\n\n    // -----------------------------\n    // Init / Utility blocks\n    // -----------------------------\n\n    /**\n     * UART初期化（TX/RXピン・ボーレート）\n     * 注意: モジュール側の既定は 115200bps（仕様）\n     */\n    //% blockId=ZETag_init_serial block=\"Init UART TX %tx|RX %rx|Baud %baud\"\n    //% subcategory=\"Init/Utility\" weight=80 blockGap=8\n    export function Init_UART(tx: SerialPin, rx: SerialPin, baud: BaudRate): void {\n        serial.redirect(tx, rx, baud);\n        serial.setRxBufferSize(64);\n        serial.setTxBufferSize(64);\n    }\n\n    /**\n     * WAKEUPピンの設定（以後、通信時はHigh維持を推奨）\n     * 仕様: 通信の10ms以上前にHigh、通信中High、Lowでスリープ\n     */\n    //% blockId=ZETag_config_wakeup block=\"Configure WAKEUP pin %pin\"\n    //% subcategory=\"Init/Utility\" weight=79 blockGap=8\n    export function Configure_WAKEUP(pin: DigitalPin): void {\n        WAKEUP_ENABLED = true;\n        WAKEUP_PIN = pin;\n        pins.digitalWritePin(WAKEUP_PIN, 0);\n    }\n\n    /**\n     * WAKE（10ms以上High）\n     */\n    //% blockId=ZETag_wake block=\"Wake module (hold High ≥10ms)\"\n    //% subcategory=\"Init/Utility\" weight=78 blockGap=8\n    export function Wake(): void {\n        if (!WAKEUP_ENABLED) return;\n        pins.digitalWritePin(WAKEUP_PIN, 1);\n        pause(12);\n    }\n\n    /**\n     * SLEEP（Low）\n     */\n    //% blockId=ZETag_sleep block=\"Sleep module\"\n    //% subcategory=\"Init/Utility\" weight=77 blockGap=8\n    export function Sleep(): void {\n        if (!WAKEUP_ENABLED) return;\n        pins.digitalWritePin(WAKEUP_PIN, 0);\n    }\n}","README.md":"","pxt.json":"{\n    \"name\": \"ZETag-R31\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1769577441099,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/**\n * makecode ZETag module Package Release 3.0 (Tailored to spec)\n * Original: Masakazu Urade (Tipyman) 2026/01/21\n */\n\n//% weight=100 color=#32CD32 icon=\"\\uf482\" block=\"ZETag R3.0\"\nnamespace ZETag_R30 {\n\n    // -----------------------------\n    // Constants & Types\n    // -----------------------------\n\n    const txBuffer = pins.createBuffer(1);\n\n    // Frame types\n    const CMD_MAC = 0x01;\n    const CMD_VERSION = 0x02;\n    const CMD_SET_TX_MODE = 0x40; // 周波数/チャネル構成\n    const CMD_TX_POWER = 0x41; // 送信電力\n    const CMD_RADIO_PARAM = 0x42; // 無線パラメータ（変調・SR・CR）\n    const CMD_OP_MODE = 0x44; // 動作モード（透過/テスト）\n    const CMD_CH_SPACE_SET = 0xF0; // チャネル間隔（設定）\n    const CMD_CH_SPACE_QRY = 0xF1; // チャネル間隔（応答/クエリ）\n    const CMD_APP_DATA = 0x80; // アプリデータ送信\n    const CMD_ERROR = 0xFF; // エラーフィードバック\n\n    // Sub mode for CMD_SET_TX_MODE (0x40)\n    const SUB_SINGLE = 0x00; // 1ch（短縮）\n    const SUB_MULTI = 0x01; // 2ch以上（汎用）\n\n    // Rx status\n    export enum RxStatus {\n        OK = 0xFF, // 正常応答\n        TIMEOUT = 1,    // 受信タイムアウト\n        SIZE_ERR = 2,    // サイズ不一致\n        ZETAG_ERR = 3,    // ZETag側エラー(TYPE=0xFF)\n        CHECKSUM_ERR = 4,    // チェックサム不一致/Type突合不一致\n        FORMAT_ERR = 5     // フォーマット不正\n    }\n\n    // --- UI enums ---\n    export enum ChSpace {\n        //% block=\"100\"\n        KHz100 = 100,\n        //% block=\"200\"\n        KHz200 = 200\n    }\n    export enum ChNum {\n        //% block=\"1\"\n        _1 = 1,\n        //% block=\"2\"\n        _2 = 2,\n        //% block=\"3\"\n        _3 = 3,\n        //% block=\"4\"\n        _4 = 4,\n        //% block=\"5\"\n        _5 = 5,\n        //% block=\"6\"\n        _6 = 6,\n    }\n    export enum TxPower {\n        //% block=\"2\"\n        dBm2 = 2,\n        //% block=\"4\"\n        dBm4 = 4,\n        //% block=\"6\"\n        dBm6 = 6,\n        //% block=\"8\"\n        dBm8 = 8,\n        //% block=\"10\"\n        dBm10 = 10,\n    }\n    export enum Mode {\n        //% block=\"4FSK(600sps,1/2)\"\n        FSK4 = 0,\n        //% block=\"(予約)8FSK\"\n        FSK8 = 1 // 仕様未定義のため送信値は 0x01 に固定\n    }\n    export enum OP_Mode {\n        //% block=\"Normal\"\n        Normal = 0,\n        //% block=\"Test\"\n        Test = 1\n    }\n\n    // Init / WAKEUP settings\n    let WAKEUP_ENABLED = false\n    let WAKEUP_PIN: DigitalPin = DigitalPin.P8\n\n    // -----------------------------\n    // Low-level helpers\n    // -----------------------------\n\n    /** TX one byte (0..255) */\n    function UART_BIN_TX(txData: number): void {\n        txBuffer.setUint8(0, txData & 0xFF);\n        serial.writeBuffer(txBuffer);\n    }\n\n    /** RX one byte (blocking); returns 0..255 */\n    function UART_BIN_RX(): number {\n        const rxBuffer = serial.readBuffer(1); // blocking\n        if (rxBuffer.length > 0) return rxBuffer[0] & 0xFF;\n        return 0;\n    }\n\n    /** Sum of bytes (8-bit) */\n    function checksum8(bytes: number[]): number {\n        let sum = 0;\n        for (let i = 0; i < bytes.length; i++) sum = (sum + (bytes[i] & 0xFF)) & 0xFF;\n        return sum & 0xFF;\n    }\n\n    /**\n     * Receive: FF 00 LEN [Type..(LEN-1 bytes)] CRC\n     * 戻り: [status(=0xFF), 0x00, LEN, Type, ..., CRC] or [RxStatus.*]\n     */\n    function receive_query(): number[] {\n        let timeoutCounter = 0;\n\n        // sync FF\n        while (true) {\n            const d = UART_BIN_RX();\n            if (d === 0xFF) break;\n            if (++timeoutCounter > 15) return [RxStatus.TIMEOUT];\n        }\n\n        // expect 00\n        const b1 = UART_BIN_RX();\n        if (b1 !== 0x00) return [RxStatus.FORMAT_ERR];\n\n        // read LEN\n        const len = UART_BIN_RX() & 0xFF;\n        if (len < 2) return [RxStatus.FORMAT_ERR]; // 最小: Type(1)+CRC(1)\n\n        // read (LEN-1) bytes (Type + Data...)\n        const typeAndData: number[] = [];\n        for (let i = 0; i < len - 1; i++) typeAndData.push(UART_BIN_RX() & 0xFF);\n\n        // read CRC\n        const crc = UART_BIN_RX() & 0xFF;\n\n        // verify checksum\n        const calc = checksum8([0xFF, 0x00, len].concat(typeAndData));\n        if (calc !== crc) return [RxStatus.CHECKSUM_ERR];\n\n        // OK\n        return [RxStatus.OK, 0x00, len].concat(typeAndData).concat([crc]);\n    }\n\n    /**\n     * sendCommand: [FF,00,LEN, Type, ...payload..., CRC]\n     * LEN = 1(Type) + payload.length + 1(CRC)\n     */\n\n    function sendCommand(type: number, payload: number[] = []): number[] {\n        // WAKEUP 高維持（必要時）\n        pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        const len = 1 + payload.length + 1;\n        const header = [0xFF, 0x00, len, type];\n        const crc = checksum8(header.concat(payload));\n\n        const frame = header.concat(payload);\n        frame.push(crc); // ← ここがポイント\n\n        for (let i = 0; i < frame.length; i++) UART_BIN_TX(frame[i]);\n\n        return receive_query();\n    }\n\n    // -----------------------------\n    // Public APIs\n    // -----------------------------\n\n    /**\n     * 完成済みフレームをそのまま送信→受信\n     * queryData[0] = RxStatus\n     */\n    //% blockId=Send_ZETag_command block=\"Send ZETag command %txArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Send_ZETag_command(txArray: number[]): number[] {\n        if (WAKEUP_ENABLED) pins.digitalWritePin(WAKEUP_PIN, 1);\n\n        for (let i = 0; i < txArray.length; i++) UART_BIN_TX(txArray[i] & 0xFF);\n\n        const rsp = receive_query();\n        if (rsp[0] !== RxStatus.OK) return rsp;\n\n        const reqType = txArray[3] & 0xFF;\n        const rspType = rsp[3] & 0xFF;\n\n        // 例外: F0(設定)→F1(応答)を許容\n        const okType =\n            (rspType === reqType) ||\n            (reqType === CMD_CH_SPACE_SET && rspType === CMD_CH_SPACE_QRY);\n\n        // エラーフレーム TYPE=0xFF\n        if (rspType === CMD_ERROR) {\n            rsp[0] = RxStatus.ZETAG_ERR;\n            return rsp;\n        }\n\n        if (!okType) rsp[0] = RxStatus.CHECKSUM_ERR;\n        return rsp;\n    }\n\n    /**\n     * アプリケーションデータ送信 (0x80), N<=30\n     */\n    //% blockId=Transmit_ZETag_data block=\"Transmit ZETag data %dataArray\"\n    //% group=\"Send data\" weight=95 blockGap=8\n    export function Transmit_ZETag_data(txArray: number[]): void {\n        if (!txArray || txArray.length < 1) return;\n        let n = txArray.length;\n        if (n > 30) n = 30; // 仕様上限\n\n        const payload = txArray.slice(0, n);\n        const rsp = sendCommand(CMD_APP_DATA, payload);\n        // 応答は 0x80 0x81（成功） or 0xFF（エラー）\n    }\n\n    /**\n     * バージョン取得 (0x02)\n     * 戻り: 上位4bit=メイン、下位4bit=サブ\n     */\n    //% blockId=Get_Protocol_Version block=\"Get Protocol Version\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    export function Get_Protocol_Version(): number {\n        const rsp = sendCommand(CMD_VERSION, []); // payloadなし\n        if (rsp[0] !== RxStatus.OK) return 0;\n\n        const main = (rsp.length > 5) ? (rsp[4] & 0x0F) : 0;\n        const sub = (rsp.length > 6) ? (rsp[5] & 0x0F) : 0;\n        return ((main << 4) | sub) & 0xFF;\n    }\n\n    /**\n     * 動作モード設定 (0x44)\n     * Normal: FF 00 03 44 00 46\n     * Test  : FF 00 05 44 01 [periodHi] [periodLo] CRC\n     */\n    //% blockId=Set_Operating_Mode block=\"Set Operating Mode %mode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% mode.min=0 mode.max=1 mode.defl=0\n    export function Set_Operating_Mode(mode: OP_Mode): void {\n        if (mode === OP_Mode.Test) {\n            // 既定周期1秒：別ブロック setTestMode() で任意指定可\n            sendCommand(CMD_OP_MODE, [0x01, 0x00, 0x01]);\n        } else {\n            // 透過（パススルー）\n            sendCommand(CMD_OP_MODE, [0x00]);\n        }\n    }\n\n    /**\n     * 送信電力設定 (0x41)\n     * 0.5dB/step, 0x10=8dBm, 0x14=10dBm\n     */\n    //% blockId=Set_TX_Power block=\"Set TX Power %txPower (dB)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txPower.min=1 txPower.max=10 txPower.defl=10\n    export function Set_TX_Power(txPower: number): void {\n        if (txPower < 1) txPower = 1;\n        if (txPower > 10) txPower = 10;\n        const reg = (txPower * 2) & 0xFF;\n        sendCommand(CMD_TX_POWER, [reg]);\n    }\n\n    /**\n     * 送信電力クエリ (0x04) → 応答 0x04 [power]\n     */\n    //% blockId=Query_TX_Power block=\"Query TX Power\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n/*    export function Query_TX_Power(): number {\n        const rsp = sendCommand(0x04, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        // rsp: [OK,0x00,LEN,0x04,power,CRC]\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n*/\n\n    /**\n     * チャネル間隔設定 (0xF0), 応答は 0xF1\n     */\n    //% blockId=Set_channel_spacing block=\"Set channel spacing %chSpace (kHz)\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% chSpace.min=100 chSpace.max=200 chSpace.defl=100\n    export function Set_channel_spacing(chSpace: number): void {\n        if (chSpace < 100) chSpace = 100;\n        if (chSpace > 200) chSpace = 200;\n        sendCommand(CMD_CH_SPACE_SET, [chSpace & 0xFF]);\n    }\n\n    /**\n     * チャネル間隔クエリ (0xF1) → 応答 0xF1 [space]\n     */\n    //% blockId=Query_channel_spacing block=\"Query channel spacing\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_channel_spacing(): number {\n        const rsp = sendCommand(CMD_CH_SPACE_QRY, []);\n        if (rsp[0] !== RxStatus.OK) return -1;\n        return (rsp.length > 4) ? (rsp[4] & 0xFF) : -1;\n    }\n\n    /**\n     * 周波数設定 (0x40)\n     * 1ch:   0x40 0x00 [Freq4B]\n     * 2..6ch:0x40 0x01 [Freq4B] [chNum] [channelNumbers...]\n     */\n    //% blockId=Set_Frequency block=\"Set Frequency %frequency (Hz) %chNum (ch) %chStep\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chNum.min=1 chNum.max=6 chNum.defl=2\n    //% chStep.min=100 chStep.max=200 chStep.defl=100\n    export function Set_Frequency(frequency: number, chNum: number, chStep: number): void {\n        // clip\n        if (chNum < 1) chNum = 1;\n        if (chNum > 6) chNum = 6;\n        if (chStep < 100) chStep = 2;\n        if (chStep > 200) chStep = 1;\n\n        // region clip（運用帯: 470–510MHz / 920–928MHz）\n        if (frequency < 470000000) frequency = 470000000;\n        else if (frequency > 928000000) frequency = 928000000;\n\n        const f3 = (frequency >>> 24) & 0xFF;\n        const f2 = (frequency >>> 16) & 0xFF;\n        const f1 = (frequency >>> 8) & 0xFF;\n        const f0 = (frequency) & 0xFF;\n\n        if (chNum === 1) {\n            // single channel (short)\n            const payload = [SUB_SINGLE, f3, f2, f1, f0];\n            sendCommand(CMD_SET_TX_MODE, payload);\n        } else {\n            // multi channel\n            const payload: number[] = [SUB_MULTI, f3, f2, f1, f0, chNum];\n            for (let n = 0; n < chNum; n++) payload.push((n * chStep) & 0xFF);\n            sendCommand(CMD_SET_TX_MODE, payload);\n        }\n    }\n\n    /**\n     * 無線パラメータ設定 (0x42)\n     * 仕様上 0x01=4FSK+600sps+1/2 のみ明記。FSK8 は予約。\n     */\n    //% blockId=Set_TX_Mode block=\"Set TX Mode %txMode\"\n    //% subcategory=\"Other\" weight=95 blockGap=8\n    //% txMode.defl=Mode.FSK4\n    export function Set_TX_Mode(txMode: Mode): void {\n        // 仕様値 0x01 固定（FSK8 選択時も暫定）\n        sendCommand(CMD_RADIO_PARAM, [0x01]);\n    }\n\n    /**\n     * MACアドレスのクエリ (0x01) → 応答 0x01 [MAC3][MAC2][MAC1][MAC0]\n     */\n    //% blockId=Query_MAC block=\"Query MAC address\"\n    //% subcategory=\"Other\" weight=70 blockGap=8\n    export function Query_MAC(): number[] {\n        const rsp = sendCommand(CMD_MAC, []);\n        if (rsp[0] !== RxStatus.OK) return [];\n        // rsp: [OK,0x00,LEN,0x01, MAC3,MAC2,MAC1,MAC0, CRC]\n        if (rsp.length < 8) return [];\n        return [rsp[4] & 0xFF, rsp[5] & 0xFF, rsp[6] & 0xFF, rsp[7] & 0xFF];\n    }\n\n    // --- まとめ設定ブロック ---\n    /**\n     * ZETag の無線設定一括適用\n     */\n    //% blockId=zetag_setting\n    //% block=\"ZETag Setting|Frequency(Hz) %frequency|Band width(kHz) %chSpace|Number of Channel(ch) %chNum|Tx Power(dB) %txPower|Mode %mode\"\n    //% group=\"ZETag Setting\" weight=95 blockGap=8\n    //% frequency.min=470000000 frequency.max=928000000 frequency.defl=922080000\n    //% chSpace.defl=ChSpace.KHz200\n    //% chNum.defl=ChNum._2\n    //% txPower.defl=TxPower.dBm8\n    //% mode.defl=Mode.FSK4\n    export function applySetting(\n        frequency: number,\n        chSpace: ChSpace,\n        chNum: ChNum,\n        txPower: TxPower,\n        mode: Mode\n    ): void {\n        // 0) 無線パラメータ（変調等）\n        Set_TX_Mode(mode);\n\n        // 1) チャネル間隔（例: 作法として 100kHz に固定）\n        Set_channel_spacing(ChSpace.KHz100);\n\n        // 2) 送信電力\n        Set_TX_Power(txPower);\n\n        // 3) 周波数＋チャネル\n        const chStep = (chSpace === ChSpace.KHz200) ? 2 : 1;\n        Set_Frequency(frequency, chNum, chStep);\n    }\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"ZETag-R31\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1769577542519}